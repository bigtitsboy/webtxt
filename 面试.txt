原型链的继承：子类的原型对象指向父类的实例，当子类的实例找不到对应的属性或方法，会往原型链上方找
()=>this指向箭头函数的父亲的父亲

● js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？
参考回答：
clientHeight：表示的是可视区域的高度，不包含border和滚动条
offsetHeight：表示可视区域的高度，包含了border和滚动条

scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。

clientTop：表示边框border的厚度，在未指定的情况下一般为0

scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。
不使用var而直接声明变量，则该变量为全局变量。

function globals() { function myObject () { name : 'Jory' }; return myObject;}修改为闭包形式 即可非全局变量

parseInt(string, radix) radix按10进制去处理字符串，碰到非数字字符，会将后面的全部无视
 parseInt() 只有一个参数的时候本身就能转化字符串，直到第一个非数，第二个参数是可以当作是第一个参数的进制，最终都会转成10进制。题目中有一个 0x12 这个方法是表示 16 进制的方法 最终化成 10 进制就是 18， 而我们在第二个参数写 10 之后，就代表把第一个参数看成一个10进制数，所以 0x12 就不会转成18，而是正常字符串，所以遇到第一个非负数就结束，就是输出0。而且第二个参数只要不写16，其他进制例如 2，8，10 都行，不要是16进制就行，因为0x12 刚好是代表16进制的数


 实现一个两列等高布局，讲讲思路
参考回答：
为了实现两列等高，可以给每列加上 padding-bottom:9999px;
margin-bottom:-9999px;同时父元素设置overflow:hidden;


基本数据类型：Undefined、Null、Boolean、Number、String，Symbol
引用数据类型 ：Object


为什么要用闭包 即有的函数只需要执行一次，其内部变量无需维护，可以用闭包。


let sy = Symbol("KK");
console.log(sy);   // Symbol(KK)
typeof(sy);        // "symbol"
// 相同参数 Symbol() 返回的值不相等
let sy1 = Symbol("kk"); 
sy === sy1;       // false

HTML DOM addEventListener() 方法
第三个参数 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。
可能值:
true - 事件句柄在捕获阶段执行
false- false- 默认。事件句柄在冒泡阶段执行


这是dom0级别：
document.getElementById("btn").onclick = function(){};
这是dom2级：
document.getElementById("btn").addEventListener("click", function(){}, false);
dom0级后面绑定的事件会覆盖前面绑定的事件，点击的时候会执行新绑定的
dom2级不会覆盖前面绑定的事件，点击的时候所有绑定的事件会依次执行一遍

vue修饰符
stop：阻止事件的冒泡
prevent：阻止事件的默认行为
once：只触发一次
self：只触发自己的事件行为时，才会执行